package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.76

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"runtime/debug"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/yordanos-habtamu/GormWithGraphql/auth/helpers"
	"github.com/yordanos-habtamu/GormWithGraphql/graph/model"
	"github.com/yordanos-habtamu/GormWithGraphql/models"
	"github.com/yordanos-habtamu/GormWithGraphql/utils"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// Map input to models.User for the service layer

	user := &model.User{
		ID:          strconv.Itoa(rand.Int()),
		FirstName:   input.FirstName,
		LastName:    input.LastName,
		Email:       input.Email,
		Password:    input.Password,
		PhoneNumber: input.PhoneNumber,
		Address:     input.Address,
		Role:        input.Role,
		IsActive:    true,
	}

	userModel := &models.User{
		FirstName:   user.FirstName,
		LastName:    user.LastName,
		Email:       user.Email,
		Password:    user.Password,
		PhoneNumber: user.PhoneNumber,
		Address:     user.Address,
		Role:        user.Role,
		IsActive:    true,
	}

	if err := r.UserService.Create(userModel); err != nil {
		return nil, err
	}

	return user, nil
}

// LoginUser is the resolver for the LoginUser field.
func (r *mutationResolver) LoginUser(ctx context.Context, input *model.LoginInput) (*model.AuthPayload, error) {
	user, err := r.UserService.FindByEmail(input.Email)
	if err != nil {
		return nil, err
	}
	token, err := r.UserService.Login(input.Email, input.Password)
	if err != nil {
		return nil, err
	}
	var userModel = &model.User{
		ID:          strconv.Itoa(rand.Int()),
		FirstName:   user.FirstName,
		LastName:    user.LastName,
		Email:       user.Email,
		Password:    user.Password,
		PhoneNumber: user.PhoneNumber,
		Address:     user.Address,
		Role:        user.Role,
		IsActive:    true,
	}

	return &model.AuthPayload{Token: token, User: userModel}, nil
}

// Register is the resolver for the Register field.
func (r *mutationResolver) Register(ctx context.Context, input model.NewUser) (*model.User, error) {
	// 1. Hash the plain password from the input
	hashedPassword, err := helpers.HashPassword(input.Password)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// 2. Build the user model for the DB (GORM model)
	userModel := &models.User{
		FirstName:   input.FirstName,
		LastName:    input.LastName,
		Email:       input.Email,
		Password:    string(hashedPassword),
		PhoneNumber: input.PhoneNumber,
		Address:     input.Address,
		Role:        input.Role,
		IsActive:    true,
	}

	// 3. Save the user in the database using your service/repository
	if err := r.UserService.Create(userModel); err != nil {
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	// 5. Prepare the user data to return via GraphQL (converted to model.User)
	graphqlUser := &model.User{
		ID:          fmt.Sprintf("%d", userModel.ID),
		FirstName:   userModel.FirstName,
		LastName:    userModel.LastName,
		Email:       userModel.Email,
		Password:    "", // never expose password
		PhoneNumber: userModel.PhoneNumber,
		Address:     userModel.Address,
		Role:        userModel.Role,
		IsActive:    userModel.IsActive,
	}

	return graphqlUser, nil
}

// LoginUser is the resolver for the LoginUser field.
func (r *mutationResolver) AddJobOffer(ctx context.Context, input model.NewJobOffer) (*model.JobOffer, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in AddJobOffer: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()
	if !utils.IsValidJobType(input.JobType) {
		return nil, fmt.Errorf("invalid job_type: %s", input.JobType)
	}
	if !utils.IsValidCategory(input.Category) {
		return nil, fmt.Errorf("invalid category: %s", input.Category)
	}

	jobOffer := &models.JobOffer{
		Type:             input.JobType,
		Title:            input.Title,
		Description:      input.Description,
		Location:         input.Location,
		OfferedBy:        uint(input.OfferedByuser),
		Category:         input.Category,
		ApplicationCount: uint(input.ApplicationCount),
		Applicants:       []models.JobApplicant{},
	}
	user, err := r.UserService.FindByID(uint(input.OfferedByuser))
	if err != nil {
		return nil, fmt.Errorf("user with ID %d not found: %v", input.OfferedByuser, err)
	}

	if err := r.JobService.Create(jobOffer); err != nil {
		return nil, fmt.Errorf("failed to create job application: %v", err)
	}

	response := &model.JobOffer{
		JobID:       strconv.Itoa(int(jobOffer.ID)),
		JobType:     jobOffer.Type,
		Title:       jobOffer.Title,
		Description: jobOffer.Description,
		Location:    jobOffer.Location,
		OfferedByuser: &model.User{
			ID:          strconv.Itoa(int(user.ID)),
			FirstName:   user.FirstName,
			LastName:    user.LastName,
			Email:       user.Email,
			Password:    user.Password,
			PhoneNumber: user.PhoneNumber,
			Address:     user.Address,
			Role:        user.Role,
			IsActive:    user.IsActive,
		},
		Category:         jobOffer.Category,
		ApplicationCount: int32(jobOffer.ApplicationCount),
	}

	return response, nil
}

// ApplyToJob is the resolver for the ApplyToJob field.
func (r *mutationResolver) ApplyToJob(ctx context.Context, input model.JobApplication) (*model.ApplicationResponse, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in ApplyToJob: %v\nStack trace: %s", r, debug.Stack())
			panic(r)
		}
	}()

	// Validate input
	if input.Proposal == "" {
		return nil, fmt.Errorf("proposal is required")
	}
	log.Printf("ApplyToJob Input: jobID=%d, userID=%d, proposal=%s", input.JobID, input.UserID, input.Proposal)

	// Verify job offer
	jobOffer, err := r.JobService.FindByID(uint(input.JobID))
	if err != nil {
		return nil, fmt.Errorf("job offer with ID %d not found: %v", input.JobID, err)
	}

	// Verify user
	user, err := r.UserService.FindByID(uint(input.UserID))
	if err != nil {
		return nil, fmt.Errorf("user with ID %d not found: %v", input.UserID, err)
	}

	// Check if user is applying to their own job
	if jobOffer.OfferedBy == user.ID {
		return nil, fmt.Errorf("you cannot apply to your own job offer")
	}

	// Update application count (without modifying Applicants)
	jobOffer.ApplicationCount--
	if err := r.JobService.Update(jobOffer); err != nil {
		return nil, fmt.Errorf("failed to update job offer: %v", err)
	}

	// Create job application
	jobApplication := &models.JobApplicant{
		JobOfferID: uint(input.JobID),
		UserID:     uint(input.UserID),
		AppliedAt:  time.Now(),
		Status:     "pending",
		Resume:     input.Proposal,
	}
	log.Printf("Creating job application: %+v", jobApplication)
	createdApplication, err := r.JobService.CreateApplication(jobApplication)
	if err != nil {
		log.Printf("Error creating job application: %v", err)
		return nil, fmt.Errorf("failed to create job application: %v", err)
	}
	log.Printf("Job application created: %+v", createdApplication)

	response := &model.ApplicationResponse{
		Response: "Application successful",
		User: &model.User{
			ID:          strconv.Itoa(int(user.ID)),
			FirstName:   user.FirstName,
			LastName:    user.LastName,
			Email:       user.Email,
			PhoneNumber: user.PhoneNumber,
			Address:     user.Address,
			Role:        user.Role,
			IsActive:    user.IsActive,
		},
	}

	return response, nil
}

// ApproveApplication is the resolver for the ApproveApplication field.
func (r *mutationResolver) ApproveApplication(ctx context.Context, input model.Approval) (*model.ApprovalResponse, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in ApproveApplication: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()
	jobApplicant, err := r.JobService.FindApplicantByID(uint(input.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to find applicant: %v", err)
	}
	if err := r.JobService.ApproveApplication(jobApplicant); err != nil {
		return nil, fmt.Errorf("failed to approve application: %v", err)
	}
	return &model.ApprovalResponse{Response: "Application Approved"}, nil
}

// RejectApplication is the resolver for the RejectApplication field.
func (r *mutationResolver) RejectApplication(ctx context.Context, input model.Approval) (*model.RejectionResponse, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in RejectApplication: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()
	jobApplicant, err := r.JobService.FindApplicantByID(uint(input.UserID))
	if err != nil {
		return nil, fmt.Errorf("failed to find applicant: %v", err)
	}
	if err := r.JobService.RejectApplication(jobApplicant); err != nil {
		return nil, fmt.Errorf("failed to reject application: %v", err)
	}
	return &model.RejectionResponse{Response: "Application Rejected"}, nil
}

// SendMessage is the resolver for the SendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, chatID string, content string, senderID int32, recieverID int32) (*model.Message, error) {
	msg := &models.Message{
		ID:       uuid.New().String(),
		ChatID:   chatID, // still a string
		Content:  content,
		SenderID: int(senderID),
		SendAt:   time.Now(),
		IsRead:   false,
	}

	// Save message to DB
	if err := r.ChatService.SendMessage(chatID, msg, int(senderID), int(recieverID)); err != nil {
		return nil, err
	}

	// Publish message to subscribers

	// Build GraphQL response
	response := &model.Message{
		ID:       msg.ID,
		Message:  msg.Content,
		SenderID: senderID,
		ChatID:   chatID, // keep as string!
		SentAt:   msg.SendAt,
	}
	r.PubSub.Publish(chatID, response)
	return response, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.UserService.GetAll()
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, u := range users {
		result = append(result, &model.User{
			ID:        strconv.Itoa(int(u.ID)),
			FirstName: u.FirstName,
			LastName:  u.LastName,
			PhoneNumber: u.PhoneNumber,
			Address: u.Address,
			Email:     u.Email,
			Role:u.Role,
		})
	}
	return result, nil
}

// Jobs is the resolver for the jobs field.
func (r *queryResolver) Jobs(ctx context.Context) ([]*model.JobOffer, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in ApplyToJob: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()
	jobs, err := r.JobService.GetAll()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch jobs: %v", err)
	}
	var result []*model.JobOffer
	for _, job := range jobs {
		result = append(result, &model.JobOffer{
			JobType:          job.Type,
			Title:            job.Title,
			Description:      job.Description,
			Location:         job.Location,
			OfferedByuser:    &model.User{ID: strconv.Itoa(int(job.OfferedBy)), FirstName: job.OfferedByUser.FirstName, LastName: job.OfferedByUser.LastName},
			Category:         job.Category,
			ApplicationCount: int32(job.ApplicationCount),
		})
	}
	return result, nil
}

// JobsWithFilter is the resolver for the jobsWithFilter field.
func (r *queryResolver) JobsWithFilter(ctx context.Context, filter *model.JobFilter) ([]*model.JobOffer, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in JobsWithFilter: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()

	var jobOfferID uint
	if filter.JobOfferID != nil {
		jobOfferID = uint(*filter.JobOfferID)
	}
	var userID uint
	if filter.UserID != nil {
		userID = uint(*filter.UserID)
	}
	var category string
	if filter.Category != nil {
		category = *filter.Category
	} else {
		category = ""
	}
	jobs, err := r.JobService.SearchJobOffers(&models.JobFilter{
		JobOfferID: jobOfferID,
		UserID:     userID,
		Category:   category,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch jobs with filter: %v", err)
	}

	var result []*model.JobOffer
	for _, job := range jobs {
		result = append(result, &model.JobOffer{
			JobID:            strconv.Itoa(int(job.ID)),
			JobType:          job.Type,
			Title:            job.Title,
			Description:      job.Description,
			Location:         job.Location,
			OfferedByuser:    &model.User{ID: strconv.Itoa(int(job.OfferedBy)), FirstName: job.OfferedByUser.FirstName, LastName: job.OfferedByUser.LastName},
			Category:         job.Category,
			ApplicationCount: int32(job.ApplicationCount),
		})
	}
	return result, nil
}

// Applicants is the resolver for the applicants field.
func (r *queryResolver) Applicants(ctx context.Context) ([]*model.Applicants, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in Applicants: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()

	applicants, err := r.JobService.FindAllApplicants()
	if err != nil {
		return nil, fmt.Errorf("failed to fetch applicants: %v", err)
	}

	var result []*model.Applicants
	for _, applicant := range applicants {
		result = append(result, &model.Applicants{
			UserID:    strconv.Itoa(int(applicant.UserID)),
			JobID:     int32(applicant.JobOfferID),
			AppliedAt: applicant.AppliedAt.Format(time.RFC3339),
			Status:    applicant.Status,
			Resume:    applicant.Resume,
		})
	}
	return result, nil
}

// ApplicantsWithfilter is the resolver for the applicantsWithfilter field.
func (r *queryResolver) ApplicantsWithfilter(ctx context.Context, filter *model.JobApplicantFilter) ([]*model.Applicants, error) {
	defer func() {
		if r := recover(); r != nil {
			log.Printf("Panic in ApplicantsWithfilter: %v\nStack trace: %s", r, debug.Stack())
			panic(r) // Re-panic for now; replace with error return if needed
		}
	}()

	var jobOfferID uint
	if filter.JobOfferID != nil {
		jobOfferID = uint(*filter.JobOfferID)
	}
	var userID uint
	if filter.UserID != nil {
		userID = uint(*filter.UserID)
	}
	var status string
	if filter.Status != nil {
		status = *filter.Status
	} else {
		status = ""
	}
	applicants, err := r.JobService.SearchJobApplicants(&models.JobApplicantFilter{
		JobOfferID: jobOfferID,
		UserID:     userID,
		Status:     status,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to fetch applicants with filter: %v", err)
	}

	var result []*model.Applicants
	for _, applicant := range applicants {
		result = append(result, &model.Applicants{
			UserID:    strconv.Itoa(int(applicant.UserID)),
			JobID:     int32(applicant.JobOfferID),
			AppliedAt: applicant.AppliedAt.Format(time.RFC3339),
			Status:    applicant.Status,
			Resume:    applicant.Resume,
		})
	}
	return result, nil
}

// MessageSent is the resolver for the messageSent field.
func (r *subscriptionResolver) MessageSent(ctx context.Context, chatID string) (<-chan *model.Message, error) {
	log.Println("Subscription started for chatID:", chatID)

	msgChan := make(chan *model.Message, 1)

	go func() {
		log.Println("Listening for disconnect on context.Done()")
		<-ctx.Done()
		log.Println("Context done for chatID:", chatID)
		close(msgChan)
	}()

	// Register subscriber
	err := r.PubSub.Subscribe(chatID, msgChan)
	if err != nil {
		log.Println("Subscription error:", err)
		return nil, err
	}

	return msgChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
